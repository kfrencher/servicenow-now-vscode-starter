/**
 * There was no where to put this information, so storing it here. These are the attributes
 * available for active directory LDAP entry:
 * actualdn,cn,description,displayName,distinguishedName,dn,
 * extensionAttributel,extensionAttribute2,groupType,instanceType,
 * internetEncoding, mail, mailNickname, me.mber, memberOf, name, objectCategory,
 * objectClass,objectGUID,objectSid,proxyAddresses,reportToOriginator,
 * sAMAccountName,sAMAccountType,showinAddressBook,source,uSNChanged,
 * uSNCreated,whenChanged,whenCreated
 */
/**
 * @class global.KLF_LdapGroupService
 * @param {Object} [config] A configuration object
 * @param {boolean} [config.includeNestedGroups=false] Includes the members of any nested groups in resolved groups.
 * Otherwise only the top level members .will be included
 * @param {string} [config.ldapServerName=LDAP] The ldap server name of the LDAP server to query against. Will be set to
 * LDAP by default if isActiveDirectoryGroups is false, LDAP-AD otherwise
 * @param {boolean} [config.isActiveDirectoryGroups=false] Configures searches to run against active directory
 * @param {string} [config.ingestTypeName=SNB_LDAP_GROUP] The sys_user_group_type that is added to a new group that is ingested by this class.
 * This will be set to SNB_LDAP_GROUP if isActiveDirectoryGroups is false, SNB_LDAP_AD otherwise
 * @param {string} [config.searchRdn=ou=Groups] The rdn to limit searches of the directory to. For LDAP groups
 * this defaults to ou=Groups. Empty string is default for AD
 * @param {string} [config.logSource=KLF_LdapGroupService] The source to add to log messages generated by this class. By default
 * KLF_LdapGroupService
 */
declare namespace global {
export function KLF_LdapGroupService(config?: {
    includeNestedGroups?: boolean;
    ldapServerName?: string;
    isActiveDirectoryGroups?: boolean;
    ingestTypeName?: string;
    searchRdn?: string;
    logSource?: string;
}): void;
export class KLF_LdapGroupService {
    /**
     * There was no where to put this information, so storing it here. These are the attributes
     * available for active directory LDAP entry:
     * actualdn,cn,description,displayName,distinguishedName,dn,
     * extensionAttributel,extensionAttribute2,groupType,instanceType,
     * internetEncoding, mail, mailNickname, me.mber, memberOf, name, objectCategory,
     * objectClass,objectGUID,objectSid,proxyAddresses,reportToOriginator,
     * sAMAccountName,sAMAccountType,showinAddressBook,source,uSNChanged,
     * uSNCreated,whenChanged,whenCreated
     */
    /**
     * @class global.KLF_LdapGroupService
     * @param {Object} [config] A configuration object
     * @param {boolean} [config.includeNestedGroups=false] Includes the members of any nested groups in resolved groups.
     * Otherwise only the top level members .will be included
     * @param {string} [config.ldapServerName=LDAP] The ldap server name of the LDAP server to query against. Will be set to
     * LDAP by default if isActiveDirectoryGroups is false, LDAP-AD otherwise
     * @param {boolean} [config.isActiveDirectoryGroups=false] Configures searches to run against active directory
     * @param {string} [config.ingestTypeName=SNB_LDAP_GROUP] The sys_user_group_type that is added to a new group that is ingested by this class.
     * This will be set to SNB_LDAP_GROUP if isActiveDirectoryGroups is false, SNB_LDAP_AD otherwise
     * @param {string} [config.searchRdn=ou=Groups] The rdn to limit searches of the directory to. For LDAP groups
     * this defaults to ou=Groups. Empty string is default for AD
     * @param {string} [config.logSource=KLF_LdapGroupService] The source to add to log messages generated by this class. By default
     * KLF_LdapGroupService
     */
    constructor(config?: {
        includeNestedGroups?: boolean;
        ldapServerName?: string;
        isActiveDirectoryGroups?: boolean;
        ingestTypeName?: string;
        searchRdn?: string;
        logSource?: string;
    });
    includeNestedGroups: boolean;
    isActiveDirectoryGroups: boolean;
    logSource: string;
    ldapServerSysId: string;
    processedGroups: any[];
    ingestTypeName: string;
    searchRdn: string;
    refreshGroupsByTypeNames: (typeNames: string[]) => void;
    refreshGroups: (groupSysIds: string[]) => void;
    refreshGroup: (groupSysId: string) => void;
    ingestGroup: (groupName: string, types?: string[]) => GlideRecord;
    getGroupByDn: (dn: string) => GlideRecord;
    ingestGroups: (groupNames: string[], types?: string[]) => GlideRecord[];
    getGroupSysIdsByTypeNames: (typeNames: string[]) => string[];
    getType: (typeName: string) => string | null;
    getTypes: (typeNames: string[]) => string[];
    getOrCreateIngestGroupType: () => string;
    createGroupFromLdapGroup: (ldapGroup: {
        cn: string;
        dn: string;
        uniquemember: string;
        members: string[];
        isAdGroup: boolean;
    }, types?: string[]) => GlideRecord;
    clearMembers: (groupSysId: string) => void;
    addMembers: (groupSysId: string, memberDNs: string[], processedGroups?: string[]) => void;
    getGroupShortNameFromSource: (source: string) => string;
    getGroupShortNameFromDn: (groupDN: string) => string;
    getGroupByName: (groupName: string, processedGroups?: string[] | null) => {
        cn: string;
        dn: string;
        uniquemember: string;
        members: string[];
        isAdGroup: boolean;
    };
    searchBeginsWith: (term: string, limit: number, onlyMailGroups: boolean) => string[];
    search: (term: string, limit: number, onlyMailGroups: boolean) => string[];
    isActiveDirectoryGroup: (dn: string) => boolean;
    defaultTransformFn: (result: Hashtable<"source" | "description" | "cn" | "dn" | "uniquemember" | "member" | "employeeNumber">, processedGroups?: string[]) => {
        cn: string;
        dn: string;
        uniquemember: string;
        members: string[];
        isAdGroup: boolean;
    };
    searchAndTransform: <T>(query: string, limit: number, transformFn: (result: Hashtable<"source" | "description" | "cn" | "dn" | "uniquemember" | "member" | "employeeNumber">, processedGroups?: string[]) => T, processedGroups?: string[] | null) => T[];
    getSearchRdn: () => string;
    getUniqueMember: (result: Hashtable<"source" | "description" | "cn" | "dn" | "uniquemember" | "member" | "employeeNumber">) => string;
    getGroupRegex: () => string;
    getPersonRegex: () => string;
    getMembers: (result: Hashtable<"source" | "description" | "cn" | "dn" | "uniquemember" | "member" | "employeeNumber">, processedGroups: string[] | null) => string[];
    exists: (groupName: string) => boolean;
    getDnFromSource: (source: string) => string;
    getNameFromDn: (dn: string) => string;
    _getLdapServerSysId: () => string;
    _getLdapServerSysIdByName: (name: string) => string;
    getDefaultLdapGroupTypeName: () => string;
    getDefaultAdGroupTypeName: () => string;
    _logWarning: (message: string) => void;
    _logError: (message: string) => void;
    _getActiveDirectoryUserEmployeeNumbers: (members: string[]) => string[];
    type: 'KLF_LdapGroupService';
}
}
/**
 *
 * @param {*} outputs
 * @param {*} steps
 * @param {*} params
 * @param {*} stepResult
 * @param {*} assertEqual
 */
declare function KLF_LdapGroupServiceTest(outputs: any, steps: any, params: any, stepResult: any, assertEqual: any): void;
/**
 * @class global.KLF_SPUtils
 * contains utility functions
 */
declare namespace global {
export function KLF_SPUtils(): void;
export class KLF_SPUtils {
    applyGlideRecordTemplate: (templateName: string, spForm: any) => void;
    getStream: (tableName: string, sysld: string) => any;
    getChangedFieldNames: (glideRecord: GlideRecord) => string[];
    getHistory: (tableName: string, sysld: string) => {
        sys_updated_on: string;
        sys_updated_by: string;
        changes: {
            /**
             * Name of the field that changed
             */
            fieldName: string;
            /**
             * Label of the field that changed
             */
            fieldLabel: string;
            /**
             * Current value of the field that changed
             */
            currentValue: string;
            /**
             * Current display value of the field that changed
             */
            currentDisplayValue: string;
            /**
             * Previous value of the field that changed
             */
            previousValue: string;
            /**
             * Previous display value of the field that changed
             */
            previousDisplayValue: string;
        }[];
    }[];
    getActivityEntries: (history: {
        sys_updated_on: string;
        sys_updated_by: string;
        changes: {
            /**
             * Name of the field that changed
             */
            fieldName: string;
            /**
             * Label of the field that changed
             */
            fieldLabel: string;
            /**
             * Current value of the field that changed
             */
            currentValue: string;
            /**
             * Current display value of the field that changed
             */
            currentDisplayValue: string;
            /**
             * Previous value of the field that changed
             */
            previousValue: string;
            /**
             * Previous display value of the field that changed
             */
            previousDisplayValue: string;
        }[];
    }[]) => {
        /**
         * Type of activity: attachment,. field_changes, comments, work_notes
         */
        element: string;
        /**
         * Display value of the type of activity
         */
        field_label: string;
        /**
         * A description of the activity that happened
         */
        value: string;
        /**
         * The label of the activity
         */
        name: string;
        /**
         * sys_id from sys_user
         */
        user_sys_id: string;
        /**
         * Date when activity happened
         */
        sys_created_on: string;
    }[];
    getSPClientUIActions: (tableName: string, current: GlideRecord, viewName?: string, actions?: SPAction[]) => SPAction[];
    filterForSPActionslnView: (spActions: SPAction[], viewName: string) => SPAction[];
    setRedirectURL: (actionSysld: string, getUrl: () => string) => void;
    type: 'KLF_SPUtils';
}
}
/**
 * @param {*} outputs
 * @param {*} steps
 * @param {*} params
 * @param {*} stepResult
 * @param {*} assertEqual
 */
declare function KLF_TestUtilsTest(outputs: any, steps: any, params: any, stepResult: any, assertEqual: any): void;
declare namespace global {
    export namespace KLF_AtfAddStepsHelper {
        function getTest(testSysId: string): GlideRecord;
        function addTestSteps(fromTestSysId: string, toTestSysId: string): void;
        function deleteTest(testSysId: string): void;
        function updateStepOrder(testSysId: string, startOrder: number): void;
        function moveSteps(fromTestSysId: string, toTestSysId: string): void;
        function copyTest(sourceTestSysId: string): string;
        function getMaxStepOrder(testSysId: string): number;
    }
    export function KLF_GlideRecordUtils(): void;
    export class KLF_GlideRecordUtils {
        glideRecordToMap: (glideRecord: GlideRecord, fields?: string[]) => {
            [x: string]: string;
        };
        deleteRecord: (tableName: string, encodedQuery: string) => void;
        insertRecord: (tableName: string, updates: any) => any;
        updateRecord: (tableName: string, encodedQuery: string, updates: any) => string[];
    }
    
    
    export namespace KLF_TestUtils {
        function deleteRecordsCreatedBy(createdBySysId: string, tableNames: string | string[]): void;
        function deleteRecordsCreatedByCommonUser(tableNames: string | string[]): void;
        function runAsCommonUser(func: Function): void;
        function runAsUser(userSysId: string, func: Function): void;
        function getCommonUser(): GlideRecord;
        function createCommonUser(): GlideRecord;
        function getAdminUser(): GlideRecord;
        function impersonateAdminUser(): [GlideRecord, string];
        function getOrCreateCommonUser(): GlideRecord;
        function impersonateCommonUser(): [GlideRecord, string];
        function impersonateUser(userSysId: string): string;
        function createGroup(groupName: string): GlideRecord;
        function createUser(userName: string): any;
        function addUserToGroup(user: GlideRecord, group: GlideRecord): void;
    }
    export function MetricUtils(): void;
    export class MetricUtils {
        createMetricInstance: (glideRecord: GlideRecord, metricDefinition: GlideRecord) => GlideRecord;
        clearMetricsByRelatedRecord: (table: string, sysId: string) => void;
    }
}
/**
 * {string} en
 * {string} dn
 * {string} description Description of group
 * {string} source DN with a prefix of 'ldap:'
 * {string?} uniquemember Concatenated list of members.  Concatenated with 'A'. This will
 * be there for ou=Groups entries. Will be empty for dc=AD entries
 * {string?} member Concatenated list of members. Concatenated with 'A'. This will be
 * therefor dc=AD entries and not for ou=Group entries
 */
type LdapResult = Hashtable<"source" | "description" | "cn" | "dn" | "uniquemember" | "member" | "employeeNumber">;
type LdapGroup = {
    cn: string;
    dn: string;
    uniquemember: string;
    members: string[];
    isAdGroup: boolean;
};
type transformFn<T> = (result: Hashtable<"source" | "description" | "cn" | "dn" | "uniquemember" | "member" | "employeeNumber">, processedGroups?: string[]) => T;
/**
 * Represents the set of changes for 1 update of a record. Each field changed
 * is stored in the changes array.
 */
type ChangeRecord = {
    sys_updated_on: string;
    sys_updated_by: string;
    changes: {
        fieldName: string;
        fieldLabel: string;
        currentValue: string;
        currentDisplayValue: string;
        previousValue: string;
        previousDisplayValue: string;
    };
};
/**
 * Represents an object that can be displayed as an entry in the Ticket Conversations widget
 * The widget requires a set of properties to be filled in to render the entry correctly. You can see how
 *  these properties are used by looking at the HTML Template section. The list is stored in "data.mergedEntries".
 */
type Activity = {
    /**
     * Type of activity: attachment,. field_changes, comments, work_notes
     */
    element: string;
    /**
     * Display value of the type of activity
     */
    field_label: string;
    /**
     * A description of the activity that happened
     */
    value: string;
    /**
     * The label of the activity
     */
    name: string;
    /**
     * sys_id from sys_user
     */
    user_sys_id: string;
    /**
     * Date when activity happened
     */
    sys_created_on: string;
};
type getUrl = () => string;
